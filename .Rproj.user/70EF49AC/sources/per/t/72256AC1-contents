#
# This is the server logic of a Shiny web application. You can run the
# application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)
library(ggplot2)
library(keyring)
library(RMySQL)

# Store email username with password

#dbSendQuery(db, " ~ ") --- отрпавить запрос
#fetch(dbSendQuery(db, " ~ ")) ---получить данные 
#dbListTables(db) # show all tables
#dbWriteTable(db, name = "mtcars", value = mtcars[,]) # Insert R's own data mtcars to form a new table
#mtcars <- dbReadTable(db, "mtcars") --- получить таблицу


# Define server logic required to draw a histogram
shinyServer(function(input, output, session) {
  rv <- shiny::reactiveValues(
    df = mtcars, #исх таблица данных
    dt_row = NULL, #выбранная строка
    add_or_edit = NULL,
    edit_button = NULL,
    keep_track_id = nrow(mtcars) + 1 #отслеживает id
  )
  output$dt_table <- DT::renderDT(
    {
      shiny::isolate(rv$df)
    },
    escape = F,
    rownames = FALSE,
    options = list(processing = FALSE)
  )
  
  proxy <- DT::dataTableProxy("dt_table")
  shiny::observe({
    DT::replaceData(proxy, rv$df, resetPaging = FALSE, rownames = FALSE)
  })
  
  ### delete row
  shiny::observeEvent(input$current_id, {
    shiny::req(!is.null(input$current_id) & stringr::str_detect(input$current_id, pattern = "delete")) #req() - check NULL, FALSE, ""
    rv$dt_row <- which(stringr::str_detect(rv$df$Buttons, pattern = paste0("\\b", input$current_id, "\\b")))
    rv$df <- rv$df[-rv$dt_row, ]
  })
  
  # when edit button is clicked, open page "card patient"
  shiny::observeEvent(input$current_id, {
    shiny::req(!is.null(input$current_id) & stringr::str_detect(input$current_id, pattern = "edit"))
    rv$dt_row <- which(stringr::str_detect(rv$df$Buttons, pattern = paste0("\\b", input$current_id, "\\b")))
    row <- rv$df[rv$dt_row, ]
    modal_dialog(
      car = row$Car, mpg = row$mpg, cyl = row$cyl, hp = row$hp, disp = row$disp, drat = row$drat,
      wt = row$wt, qsec = row$qsec, vs = mtcars$vs, am = mtcars$am, gear = row$gear, carb = row$carb,
      selected_am = row$am, selected_vs = row$vs, edit = TRUE
    )
    rv$add_or_edit <- NULL
  })
  
  # when final edit button (in modal button) is clicked, table will be changed 
  shiny::observeEvent(input$final_edit, {
    shiny::req(!is.null(input$current_id) & stringr::str_detect(input$current_id, pattern = "edit") & is.null(rv$add_or_edit))
    rv$edited_row <- dplyr::tibble(
      Car = input$car_name,
      mpg = input$mpg,
      cyl = input$cyl,
      disp = input$disp,
      hp = input$hp,
      drat = input$drat,
      wt = input$wt,
      qsec = input$qsec,
      vs = input$vs,
      am = input$am,
      gear = input$gear,
      carb = input$carb,
      Buttons = rv$df$Buttons[rv$dt_row]
    )
    rv$df[rv$dt_row, ] <- rv$edited_row
  })
  
  shiny::observeEvent(input$add_car, {
    modal_dialog(
      car = "", mpg = "", cyl = "", hp = "", disp = "", drat = "",
      wt = "", qsec = "", vs = mtcars$vs, am = mtcars$am, gear = "", carb = "",
      selected_am = NULL, selected_vs = NULL, edit = FALSE
    )
    rv$add_or_edit <- 1
  })
  
  shiny::observeEvent(input$final_edit, {
    shiny::req(rv$add_or_edit == 1)
    add_row <- dplyr::tibble(
      Car = input$car_name,
      mpg = input$mpg,
      cyl = input$cyl,
      disp = input$disp,
      hp = input$hp,
      drat = input$drat,
      wt = input$wt,
      qsec = input$qsec,
      vs = input$vs,
      am = input$am,
      gear = input$gear,
      carb = input$carb,
      Buttons = create_btns(rv$keep_track_id)
    )
    rv$df <- add_row %>%
      dplyr::bind_rows(rv$df)
    
    rv$keep_track_id <- rv$keep_track_id + 1
  })
  
  shiny::observeEvent(input$dismiss_modal, {
    shiny::removeModal()
  })
  
  shiny::observeEvent(input$final_edit, {
    shiny::removeModal()
  })
  
})
